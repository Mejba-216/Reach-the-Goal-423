from OpenGL.GLUT import GLUT_BITMAP_HELVETICA_18
from OpenGL.GLUT import GLUT_BITMAP_TIMES_ROMAN_24
from OpenGL.GL import *
from OpenGL.GLUT import *
from OpenGL.GLU import *
import math
import random
import time

camera_pos = (0,600,600)

fovY = 120  
GRID_LENGTH = 600 
rand_var = 423


def draw_text(x, y, text, font=GLUT_BITMAP_HELVETICA_18):
    glColor3f(1,1,1)
    glMatrixMode(GL_PROJECTION)
    glPushMatrix()
    glLoadIdentity() 
    gluOrtho2D(0, 1000, 0, 800)  
    glMatrixMode(GL_MODELVIEW)
    glPushMatrix()
    glLoadIdentity()
    glRasterPos2f(x, y)
    for ch in text:
        glutBitmapCharacter(font, ord(ch))
    glPopMatrix()
    glMatrixMode(GL_PROJECTION)
    glPopMatrix()
    glMatrixMode(GL_MODELVIEW)



def arena():
    arena_length =  GRID_LENGTH
    cell_size = (2 * GRID_LENGTH) / 12  

    glBegin(GL_QUADS)
    i = 0
    while i < 12:
        j = 0
        while j < 12:
            if (i + j) % 2 == 0:
                glColor3f(1, 1, 1)  
            else:
                glColor3f(0.2, 0.4, 0.7) 

            x = - arena_length + i * cell_size
            y = -arena_length + j * cell_size

            glVertex3f(x, y, 0)
            glVertex3f(x + cell_size, y, 0)
            glVertex3f(x + cell_size, y + cell_size, 0)
            glVertex3f(x, y + cell_size, 0)

            j += 1
        i += 1
    glEnd()

def wall():
    arena_length =  GRID_LENGTH
    walls = [
        ((-arena_length, -arena_length, 0), (-arena_length, arena_length, 0), (-arena_length, arena_length, 120), (-arena_length, -arena_length, 120), (0.9, 0.2, 0.9)), 
        (( arena_length, -arena_length, 0), (arena_length, arena_length, 0), ( arena_length, arena_length, 120), ( arena_length, -arena_length, 120), (0.9, 0.2, 0.9)), 
        ((-arena_length, arena_length, 0), ( arena_length,arena_length, 0), ( arena_length, arena_length, 120), (-arena_length, arena_length, 120), (0.9, 0.2, 0.9)),
        ((-arena_length, -arena_length, 0), ( arena_length, -arena_length, 0), ( arena_length, -arena_length, 120), (-arena_length, -arena_length, 120), (0.9, 0.2, 0.9)), 
    ]

    for i in walls:
        ver, color = i[:4], i[4]
        glColor3f(*color)
        glBegin(GL_QUADS)
        for j in ver:
            glVertex3f(*j)  
        glEnd()

thorn_positions = []   
thorn_speed = 2       
wave_phase = 0       
last_wave_time = time.time()

def thorn_wave():
    global thorn_positions, wave_phase, last_wave_time
    thorn_positions = []
    cols = range(12)
    if wave_phase == 0:
    
        cols = []
        for c in range(12):
            if c % 2 == 1:
               cols.append(c)
    else:
    
       cols = []
       for c in range(12):
        if c % 2 == 0:
            cols.append(c)


    for c in cols:
        thorn_positions.append([c, 0])  

    wave_phase = 1 - wave_phase  
    last_wave_time = time.time()      


def animate_thorns(dt):
    global thorn_positions
    for thorn in thorn_positions:
        thorn[1] += thorn_speed * dt  
   
    thorn_positions = [t for t in thorn_positions if t[1] <= 11]


def thorns():
    glColor3f(1,0,0)
    for col, row in thorn_positions:
        world_pos = grid_to_world(int(row), col, 10)
        x, y, z = world_pos
        h = 40
        glPushMatrix()
        glTranslatef(x, y, z)
        glBegin(GL_TRIANGLES)
        glVertex3f(0, 0, 0)
        glVertex3f(-h/2, 0, h)
        glVertex3f(h/2, 0, h)
        glEnd()
        glPopMatrix()


prev_time = time.time()

def update():
    global prev_time
    current_time = time.time()
    dt = current_time - prev_time
    prev_time = current_time

    
    if not thorn_positions and current_time - last_wave_time >= 1:
        thorn_wave()

    animate_thorns(dt)
    glutPostRedisplay()


def draw_text(x, y, text, font=GLUT_BITMAP_HELVETICA_18):
    glColor3f(1,1,1)
    glMatrixMode(GL_PROJECTION)
    glPushMatrix()
    glLoadIdentity()
    
    # Set up an orthographic projection that matches window coordinates
    gluOrtho2D(0, 1000, 0, 800)  # left, right, bottom, top

    
    glMatrixMode(GL_MODELVIEW)
    glPushMatrix()
    glLoadIdentity()
    
    # Draw text at (x, y) in screen coordinates
    glRasterPos2f(x, y)
    for ch in text:
        glutBitmapCharacter(font, ord(ch))
    
    # Restore original projection and modelview matrices
    glPopMatrix()
    glMatrixMode(GL_PROJECTION)
    glPopMatrix()
    glMatrixMode(GL_MODELVIEW)


def draw_shapes():

    glPushMatrix()  # Save the current matrix state
    glColor3f(1, 0, 0)
    glTranslatef(0, 0, 0)  
    glutSolidCube(60) # Take cube size as the parameter
    glTranslatef(0, 0, 100) 
    glColor3f(0, 1, 0)
    glutSolidCube(60) 

    glColor3f(1, 1, 0)
    glScalef(2, 2, 2)
    gluCylinder(gluNewQuadric(), 40, 5, 150, 10, 10)  # parameters are: quadric, base radius, top radius, height, slices, stacks
    glTranslatef(100, 0, 100) 
    glRotatef(90, 0, 1, 0)  # parameters are: angle, x, y, z
    gluCylinder(gluNewQuadric(), 40, 5, 150, 10, 10)

    glColor3f(0, 1, 1)
    glTranslatef(300, 0, 100) 
    gluSphere(gluNewQuadric(), 80, 10, 10)  # parameters are: quadric, radius, slices, stacks

    glPopMatrix()  # Restore the previous matrix state


def keyboardListener(key, x, y):
    global player_row, player_col, pos

    key = key.decode("utf-8").lower() 
    if key == 's' and player_row < 11:       
        player_row += 1
    elif key == 'w' and player_row > 0:     
        player_row -= 1
    elif key == 'd' and player_col > 0:    
        player_col -= 1
    elif key == 'a' and player_col < 11:     
        player_col += 1

    
    pos = grid_to_world(player_row, player_col, 10)
    glutPostRedisplay()

def specialKeyListener(key, x, y):
    """
    Handles special key inputs (arrow keys) for adjusting the camera angle and height.
    """
    global camera_pos
    x, y, z = camera_pos
    # Move camera up (UP arrow key)
    # if key == GLUT_KEY_UP:

    # # Move camera down (DOWN arrow key)
    # if key == GLUT_KEY_DOWN:

    # moving camera left (LEFT arrow key)
    if key == GLUT_KEY_LEFT:
        x -= 1  # Small angle decrement for smooth movement

    # moving camera right (RIGHT arrow key)
    if key == GLUT_KEY_RIGHT:
        x += 1  # Small angle increment for smooth movement

    camera_pos = (x, y, z)


def mouseListener(button, state, x, y):
    """
    Handles mouse inputs for firing bullets (left click) and toggling camera mode (right click).
    """
        # # Left mouse button fires a bullet
        # if button == GLUT_LEFT_BUTTON and state == GLUT_DOWN:

        # # Right mouse button toggles camera tracking mode
        # if button == GLUT_RIGHT_BUTTON and state == GLUT_DOWN:


def setupCamera():
    """
    Configures the camera's projection and view settings.
    Uses a perspective projection and positions the camera to look at the target.
    """
    glMatrixMode(GL_PROJECTION)  # Switch to projection matrix mode
    glLoadIdentity()  # Reset the projection matrix
    # Set up a perspective projection (field of view, aspect ratio, near clip, far clip)
    gluPerspective(fovY, 1.25, 0.1, 1500) # Think why aspect ration is 1.25?
    glMatrixMode(GL_MODELVIEW)  # Switch to model-view matrix mode
    glLoadIdentity()  # Reset the model-view matrix

    # Extract camera position and look-at target
    x, y, z = camera_pos
    # Position the camera and set its orientation
    gluLookAt(x, y, z,  # Camera position
              0, 0, 0,  # Look-at target
              0, 0, 1)  # Up vector (z-axis)


def idle():
    """
    Idle function that runs continuously:
    - Triggers screen redraw for real-time updates.
    """
    # Ensure the screen updates with the latest changes
    glutPostRedisplay()


def showScreen():
    """
    Display function to render the game scene:
    - Clears the screen and sets up the camera.
    - Draws everything of the screen
    """
    # Clear color and depth buffers
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
    glLoadIdentity()  # Reset modelview matrix
    glViewport(0, 0, 1000, 800)  # Set viewport size

    setupCamera()  # Configure camera perspective

    # Draw a random points
    glPointSize(20)
    glBegin(GL_POINTS)
    glVertex3f(-GRID_LENGTH, GRID_LENGTH, 0)
    glEnd()

    # Draw the grid (game floor)
    glBegin(GL_QUADS)
    
    glColor3f(1, 1, 1)
    glVertex3f(-GRID_LENGTH, GRID_LENGTH, 0)
    glVertex3f(0, GRID_LENGTH, 0)
    glVertex3f(0, 0, 0)
    glVertex3f(-GRID_LENGTH, 0, 0)

    glVertex3f(GRID_LENGTH, -GRID_LENGTH, 0)
    glVertex3f(0, -GRID_LENGTH, 0)
    glVertex3f(0, 0, 0)
    glVertex3f(GRID_LENGTH, 0, 0)


    glColor3f(0.7, 0.5, 0.95)
    glVertex3f(-GRID_LENGTH, -GRID_LENGTH, 0)
    glVertex3f(-GRID_LENGTH, 0, 0)
    glVertex3f(0, 0, 0)
    glVertex3f(0, -GRID_LENGTH, 0)

    glVertex3f(GRID_LENGTH, GRID_LENGTH, 0)
    glVertex3f(GRID_LENGTH, 0, 0)
    glVertex3f(0, 0, 0)
    glVertex3f(0, GRID_LENGTH, 0)
    glEnd()

    # Display game info text at a fixed screen position
    draw_text(10, 770, f"A Random Fixed Position Text")
    draw_text(10, 740, f"See how the position and variable change?: {rand_var}")

    draw_shapes()

    # Swap buffers for smooth rendering (double buffering)
    glutSwapBuffers()


# Main function to set up OpenGL window and loop
def main():
    glutInit()
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH)  # Double buffering, RGB color, depth test
    glutInitWindowSize(1000, 800)  # Window size
    glutInitWindowPosition(0, 0)  # Window position
    wind = glutCreateWindow(b"3D OpenGL Intro")  # Create the window

    glutDisplayFunc(showScreen)  # Register display function
    glutKeyboardFunc(keyboardListener)  # Register keyboard listener
    glutSpecialFunc(specialKeyListener)
    glutMouseFunc(mouseListener)
    glutIdleFunc(idle)  # Register the idle function to move the bullet automatically

    glutMainLoop()  # Enter the GLUT main loop

if __name__ == "__main__":
    main()



# 4 guard walls on the ground
shield_walls = [
    {'cx': -3*CELL_SIZE/2, 'cy': 2*CELL_SIZE,   'w': 2*CELL_SIZE, 'd': 0.7*CELL_SIZE, 'color':(0.35,0.8,0.5)},
    {'cx':  3*CELL_SIZE/2, 'cy': 2*CELL_SIZE,   'w': 2*CELL_SIZE, 'd': 0.7*CELL_SIZE, 'color':(0.35,0.8,0.9)},
    {'cx': -3*CELL_SIZE/2, 'cy': 6*CELL_SIZE/2, 'w': 2*CELL_SIZE, 'd': 0.7*CELL_SIZE, 'color':(0.60,0.6,0.95)},
    {'cx':  3*CELL_SIZE/2, 'cy': 6*CELL_SIZE/2, 'w': 2*CELL_SIZE, 'd': 0.7*CELL_SIZE, 'color':(0.60,0.6,0.95)},
]
selected_shield = 0  # press keys 1..4 to choose which shield to move

# Hide timer (max seconds allowed behind any shield)
HIDE_LIMIT = 3.0
hide_start_time = None

def point_in_rect(px, py, cx, cy, w, d):
    return (cx - w/2) <= px <= (cx + w/2) and (cy - d/2) <= py <= (cy + d/2)

def draw_shields():
    """Draw the 4 guard walls (selected one is highlighted)."""
    for i, s in enumerate(shield_walls):
        r,g,b = s['color']
        if i == selected_shield:
            r = min(1.0, r+0.25); g = min(1.0, g+0.25); b = min(1.0, b+0.25)
        glColor3f(r,g,b)
        glBegin(GL_QUADS)
        glVertex3f(s['cx'] - s['w']/2, s['cy'] - s['d']/2, 2.0)
        glVertex3f(s['cx'] + s['w']/2, s['cy'] - s['d']/2, 2.0)
        glVertex3f(s['cx'] + s['w']/2, s['cy'] + s['d']/2, 2.0)
        glVertex3f(s['cx'] - s['w']/2, s['cy'] + s['d']/2, 2.0)
        glEnd()

def check_player_inside_any_shield():
    """Returns True if player is hiding inside any shield area."""
    px, py = player_world_xy()
    for s in shield_walls:
        if point_in_rect(px, py, s['cx'], s['cy'], s['w'], s['d']):
            return True
    return False


def keyboardListener(key, x, y):
    global player_row, player_col, pos, selected_shield
    key = key.decode("utf-8").lower()

    # ... (WASD player movement kept as-is)

    # Select which shield to move: keys 1..4
    if key in ('1','2','3','4'):
        selected_shield = int(key) - 1

    pos = grid_to_world(player_row, player_col, 10)
    glutPostRedisplay()

def specialKeyListener(key, x, y):
    """Arrow keys move the currently selected shield."""
    global camera_pos, shield_walls, selected_shield
    xcam, ycam, zcam = camera_pos

    move = CELL_SIZE/1.5
    if key == GLUT_KEY_LEFT:
        shield_walls[selected_shield]['cx'] = clamp(shield_walls[selected_shield]['cx'] - move, -GRID_LENGTH, GRID_LENGTH)
    elif key == GLUT_KEY_RIGHT:
        shield_walls[selected_shield]['cx'] = clamp(shield_walls[selected_shield]['cx'] + move, -GRID_LENGTH, GRID_LENGTH)
    elif key == GLUT_KEY_UP:
        shield_walls[selected_shield]['cy'] = clamp(shield_walls[selected_shield]['cy'] + move, -GRID_LENGTH, GRID_LENGTH)
    elif key == GLUT_KEY_DOWN:
        shield_walls[selected_shield]['cy'] = clamp(shield_walls[selected_shield]['cy'] - move, -GRID_LENGTH, GRID_LENGTH)

    camera_pos = (xcam, ycam, zcam)
# ========= PERSON 2: Shields — GAME LOGIC (START) =========
def update():
    global prev_time, hide_start_time, game_over, game_over_reason, pos
    current_time = time.time()
    dt = current_time - prev_time
    prev_time = current_time

    # (thorns timing/motion unchanged)
    if not thorn_positions and current_time - last_wave_time >= 1:
        thorn_wave()
    animate_thorns(dt)

    if game_over:
        glutPostRedisplay()
        return

    if check_collision_player_thorns():
        game_over = True
        game_over_reason = "Hit by thorn"
        glutPostRedisplay()
        return

    # Game over if staying behind any shield > HIDE_LIMIT seconds
    if check_player_inside_any_shield():
        if hide_start_time is None:
            hide_start_time = current_time
        else:
            if (current_time - hide_start_time) >= HIDE_LIMIT:
                game_over = True
                game_over_reason = f"Stayed behind shield > {int(HIDE_LIMIT)}s"
                glutPostRedisplay()
                return
    else:
        hide_start_time = None

    glutPostRedisplay()

# Place inside showScreen() after drawing 3D scene:
draw_text(10, 770, f"Shields: select [1..4], move with Arrow Keys | Hide limit: {HIDE_LIMIT:.0f}s")
if hide_start_time:
    t = time.time() - hide_start_time
    draw_text(10, 740, f"Hiding: {t:.1f}s")







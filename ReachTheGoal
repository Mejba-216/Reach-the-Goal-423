from OpenGL.GLUT import GLUT_BITMAP_HELVETICA_18
from OpenGL.GLUT import GLUT_BITMAP_TIMES_ROMAN_24
from OpenGL.GL import *
from OpenGL.GLUT import *
from OpenGL.GLU import *
import math
import random
import time

camera_pos = (0,600,600)

fovY = 120  
GRID_LENGTH = 600 
rand_var = 423


def draw_text(x, y, text, font=GLUT_BITMAP_HELVETICA_18):
    glColor3f(1,1,1)
    glMatrixMode(GL_PROJECTION)
    glPushMatrix()
    glLoadIdentity() 
    gluOrtho2D(0, 1000, 0, 800)  
    glMatrixMode(GL_MODELVIEW)
    glPushMatrix()
    glLoadIdentity()
    glRasterPos2f(x, y)
    for ch in text:
        glutBitmapCharacter(font, ord(ch))
    glPopMatrix()
    glMatrixMode(GL_PROJECTION)
    glPopMatrix()
    glMatrixMode(GL_MODELVIEW)



def arena():
    arena_length =  GRID_LENGTH
    cell_size = (2 * GRID_LENGTH) / 12  

    glBegin(GL_QUADS)
    i = 0
    while i < 12:
        j = 0
        while j < 12:
            if (i + j) % 2 == 0:
                glColor3f(1, 1, 1)  
            else:
                glColor3f(0.2, 0.4, 0.7) 

            x = - arena_length + i * cell_size
            y = -arena_length + j * cell_size

            glVertex3f(x, y, 0)
            glVertex3f(x + cell_size, y, 0)
            glVertex3f(x + cell_size, y + cell_size, 0)
            glVertex3f(x, y + cell_size, 0)

            j += 1
        i += 1
    glEnd()

def wall():
    arena_length =  GRID_LENGTH
    walls = [
        ((-arena_length, -arena_length, 0), (-arena_length, arena_length, 0), (-arena_length, arena_length, 120), (-arena_length, -arena_length, 120), (0.9, 0.2, 0.9)), 
        (( arena_length, -arena_length, 0), (arena_length, arena_length, 0), ( arena_length, arena_length, 120), ( arena_length, -arena_length, 120), (0.9, 0.2, 0.9)), 
        ((-arena_length, arena_length, 0), ( arena_length,arena_length, 0), ( arena_length, arena_length, 120), (-arena_length, arena_length, 120), (0.9, 0.2, 0.9)),
        ((-arena_length, -arena_length, 0), ( arena_length, -arena_length, 0), ( arena_length, -arena_length, 120), (-arena_length, -arena_length, 120), (0.9, 0.2, 0.9)), 
    ]

    for i in walls:
        ver, color = i[:4], i[4]
        glColor3f(*color)
        glBegin(GL_QUADS)
        for j in ver:
            glVertex3f(*j)  
        glEnd()

thorn_positions = []   
thorn_speed = 2       
wave_phase = 0       
last_wave_time = time.time()

def thorn_wave():
    global thorn_positions, wave_phase, last_wave_time
    thorn_positions = []
    cols = range(12)
    if wave_phase == 0:
    
        cols = []
        for c in range(12):
            if c % 2 == 1:
               cols.append(c)
    else:
    
       cols = []
       for c in range(12):
        if c % 2 == 0:
            cols.append(c)


    for c in cols:
        thorn_positions.append([c, 0])  

    wave_phase = 1 - wave_phase  
    last_wave_time = time.time()      


def animate_thorns(dt):
    global thorn_positions
    for thorn in thorn_positions:
        thorn[1] += thorn_speed * dt  
   
    thorn_positions = [t for t in thorn_positions if t[1] <= 11]


def thorns():
    glColor3f(1,0,0)
    for col, row in thorn_positions:
        world_pos = grid_to_world(int(row), col, 10)
        x, y, z = world_pos
        h = 40
        glPushMatrix()
        glTranslatef(x, y, z)
        glBegin(GL_TRIANGLES)
        glVertex3f(0, 0, 0)
        glVertex3f(-h/2, 0, h)
        glVertex3f(h/2, 0, h)
        glEnd()
        glPopMatrix()


prev_time = time.time()


def random_shield():
    return {
        'cx': random.randint(-5, 5) * (CELL_SIZE/2),
        'cy': random.randint(-5, 5) * (CELL_SIZE/2),
        'w': 2*CELL_SIZE,
        'd': 0.7*CELL_SIZE,
        'color': (random.random(), random.random(), random.random()),
        'dx': random.choice([-1,1]) * CELL_SIZE/4,
        'dy': random.choice([-1,1]) * CELL_SIZE/4
    }

shield_walls = [random_shield() for _ in range(4)]
selected_shield = 0  
HIDE_LIMIT = 3.0
hide_start_time = None

def point_in_rect(px, py, cx, cy, w, d):
    return (cx - w/2) <= px <= (cx + w/2) and (cy - d/2) <= py <= (cy + d/2)

def draw_shields():
    for i, s in enumerate(shield_walls):
        r,g,b = s['color']
        if i == selected_shield:
            r = min(1.0, r+0.25); g = min(1.0, g+0.25); b = min(1.0, b+0.25)
        glColor3f(r,g,b)
        glBegin(GL_QUADS)
        glVertex3f(s['cx'] - s['w']/2, s['cy'] - s['d']/2, 2.0)
        glVertex3f(s['cx'] + s['w']/2, s['cy'] - s['d']/2, 2.0)
        glVertex3f(s['cx'] + s['w']/2, s['cy'] + s['d']/2, 2.0)
        glVertex3f(s['cx'] - s['w']/2, s['cy'] + s['d']/2, 2.0)
        glEnd()

def move_shields(dt):
    for s in shield_walls:
        s['cx'] += s['dx'] * dt
        s['cy'] += s['dy'] * dt
        if abs(s['cx']) > GRID_LENGTH - CELL_SIZE:
            s['dx'] *= -1
        if abs(s['cy']) > GRID_LENGTH - CELL_SIZE:
            s['dy'] *= -1

def check_player_inside_any_shield():
    px, py = player_world_xy()
    for s in shield_walls:
        if point_in_rect(px, py, s['cx'], s['cy'], s['w'], s['d']):
            return True
    return False

def update():
    global prev_time, hide_start_time, game_over, game_over_reason, pos
    current_time = time.time()
    dt = current_time - prev_time
    prev_time = current_time

    if not thorn_positions and current_time - last_wave_time >= 1:
        thorn_wave()
    animate_thorns(dt)
    move_shields(dt)  # âœ… shields move automatically

    if game_over:
        glutPostRedisplay()
        return

    if check_collision_player_thorns():
        game_over = True
        game_over_reason = "Hit by thorn"
        glutPostRedisplay()
        return

    if check_player_inside_any_shield():
        if hide_start_time is None:
            hide_start_time = current_time
        else:
            if (current_time - hide_start_time) >= HIDE_LIMIT:
                game_over = True
                game_over_reason = f"Stayed behind shield > {int(HIDE_LIMIT)}s"
                glutPostRedisplay()
                return
    else:
        hide_start_time = None

    glutPostRedisplay()

# ================= MAIN RENDER LOOP =================
def setupCamera():
    glMatrixMode(GL_PROJECTION)
    glLoadIdentity()
    gluPerspective(fovY, 1.25, 0.1, 1500)
    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()
    x, y, z = camera_pos
    gluLookAt(x, y, z, 0, 0, 0, 0, 0, 1)

def showScreen():
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
    glLoadIdentity()
    glViewport(0, 0, 1000, 800)
    setupCamera()

    arena()
    wall()
    thorns()
    draw_shields()

    draw_text(10, 770, f"Shields: select [1..4], move with Arrow Keys | Hide limit: {HIDE_LIMIT:.0f}s")
    if hide_start_time:
        t = time.time() - hide_start_time
        draw_text(10, 740, f"Hiding: {t:.1f}s")
    if game_over:
        draw_text(400, 400, f"GAME OVER: {game_over_reason}", GLUT_BITMAP_TIMES_ROMAN_24)

    glutSwapBuffers()

def update():
    global prev_time
    current_time = time.time()
    dt = current_time - prev_time
    prev_time = current_time

    
    if not thorn_positions and current_time - last_wave_time >= 1:
        thorn_wave()

    animate_thorns(dt)
    glutPostRedisplay()


def draw_text(x, y, text, font=GLUT_BITMAP_HELVETICA_18):
    glColor3f(1,1,1)
    glMatrixMode(GL_PROJECTION)
    glPushMatrix()
    glLoadIdentity()
    
    # Set up an orthographic projection that matches window coordinates
    gluOrtho2D(0, 1000, 0, 800)  # left, right, bottom, top

    
    glMatrixMode(GL_MODELVIEW)
    glPushMatrix()
    glLoadIdentity()
    
    # Draw text at (x, y) in screen coordinates
    glRasterPos2f(x, y)
    for ch in text:
        glutBitmapCharacter(font, ord(ch))
    
    # Restore original projection and modelview matrices
    glPopMatrix()
    glMatrixMode(GL_PROJECTION)
    glPopMatrix()
    glMatrixMode(GL_MODELVIEW)


def draw_shapes():

    glPushMatrix()  # Save the current matrix state
    glColor3f(1, 0, 0)
    glTranslatef(0, 0, 0)  
    glutSolidCube(60) # Take cube size as the parameter
    glTranslatef(0, 0, 100) 
    glColor3f(0, 1, 0)
    glutSolidCube(60) 

    glColor3f(1, 1, 0)
    glScalef(2, 2, 2)
    gluCylinder(gluNewQuadric(), 40, 5, 150, 10, 10)  # parameters are: quadric, base radius, top radius, height, slices, stacks
    glTranslatef(100, 0, 100) 
    glRotatef(90, 0, 1, 0)  # parameters are: angle, x, y, z
    gluCylinder(gluNewQuadric(), 40, 5, 150, 10, 10)

    glColor3f(0, 1, 1)
    glTranslatef(300, 0, 100) 
    gluSphere(gluNewQuadric(), 80, 10, 10)  # parameters are: quadric, radius, slices, stacks

    glPopMatrix()  # Restore the previous matrix state


def keyboardListener(key, x, y):
    global player_row, player_col, pos

    key = key.decode("utf-8").lower() 
    if key == 's' and player_row < 11:       
        player_row += 1
    elif key == 'w' and player_row > 0:     
        player_row -= 1
    elif key == 'd' and player_col > 0:    
        player_col -= 1
    elif key == 'a' and player_col < 11:     
        player_col += 1

    
    pos = grid_to_world(player_row, player_col, 10)
    glutPostRedisplay()

def specialKeyListener(key, x, y):
    """
    Handles special key inputs (arrow keys) for adjusting the camera angle and height.
    """
    global camera_pos
    x, y, z = camera_pos
    # Move camera up (UP arrow key)
    # if key == GLUT_KEY_UP:

    # # Move camera down (DOWN arrow key)
    # if key == GLUT_KEY_DOWN:

    # moving camera left (LEFT arrow key)
    if key == GLUT_KEY_LEFT:
        x -= 1  # Small angle decrement for smooth movement

    # moving camera right (RIGHT arrow key)
    if key == GLUT_KEY_RIGHT:
        x += 1  # Small angle increment for smooth movement

    camera_pos = (x, y, z)


def mouseListener(button, state, x, y):
    """
    Handles mouse inputs for firing bullets (left click) and toggling camera mode (right click).
    """
        # # Left mouse button fires a bullet
        # if button == GLUT_LEFT_BUTTON and state == GLUT_DOWN:

        # # Right mouse button toggles camera tracking mode
        # if button == GLUT_RIGHT_BUTTON and state == GLUT_DOWN:


def setupCamera():
    """
    Configures the camera's projection and view settings.
    Uses a perspective projection and positions the camera to look at the target.
    """
    glMatrixMode(GL_PROJECTION)  # Switch to projection matrix mode
    glLoadIdentity()  # Reset the projection matrix
    # Set up a perspective projection (field of view, aspect ratio, near clip, far clip)
    gluPerspective(fovY, 1.25, 0.1, 1500) # Think why aspect ration is 1.25?
    glMatrixMode(GL_MODELVIEW)  # Switch to model-view matrix mode
    glLoadIdentity()  # Reset the model-view matrix

    # Extract camera position and look-at target
    x, y, z = camera_pos
    # Position the camera and set its orientation
    gluLookAt(x, y, z,  # Camera position
              0, 0, 0,  # Look-at target
              0, 0, 1)  # Up vector (z-axis)


def idle():
    """
    Idle function that runs continuously:
    - Triggers screen redraw for real-time updates.
    """
    # Ensure the screen updates with the latest changes
    glutPostRedisplay()


def showScreen():
    """
    Display function to render the game scene:
    - Clears the screen and sets up the camera.
    - Draws everything of the screen
    """
    # Clear color and depth buffers
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
    glLoadIdentity()  # Reset modelview matrix
    glViewport(0, 0, 1000, 800)  # Set viewport size

    setupCamera()  # Configure camera perspective

    # Draw a random points
    glPointSize(20)
    glBegin(GL_POINTS)
    glVertex3f(-GRID_LENGTH, GRID_LENGTH, 0)
    glEnd()

    # Draw the grid (game floor)
    glBegin(GL_QUADS)
    
    glColor3f(1, 1, 1)
    glVertex3f(-GRID_LENGTH, GRID_LENGTH, 0)
    glVertex3f(0, GRID_LENGTH, 0)
    glVertex3f(0, 0, 0)
    glVertex3f(-GRID_LENGTH, 0, 0)

    glVertex3f(GRID_LENGTH, -GRID_LENGTH, 0)
    glVertex3f(0, -GRID_LENGTH, 0)
    glVertex3f(0, 0, 0)
    glVertex3f(GRID_LENGTH, 0, 0)


    glColor3f(0.7, 0.5, 0.95)
    glVertex3f(-GRID_LENGTH, -GRID_LENGTH, 0)
    glVertex3f(-GRID_LENGTH, 0, 0)
    glVertex3f(0, 0, 0)
    glVertex3f(0, -GRID_LENGTH, 0)

    glVertex3f(GRID_LENGTH, GRID_LENGTH, 0)
    glVertex3f(GRID_LENGTH, 0, 0)
    glVertex3f(0, 0, 0)
    glVertex3f(0, GRID_LENGTH, 0)
    glEnd()

    # Display game info text at a fixed screen position
    draw_text(10, 770, f"A Random Fixed Position Text")
    draw_text(10, 740, f"See how the position and variable change?: {rand_var
    arena()
    player()
    throns()

    draw_shapes()

    # Swap buffers for smooth rendering (double buffering)
    glutSwapBuffers()


# Main function to set up OpenGL window and loop
def main():
    glutInit()
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH)  # Double buffering, RGB color, depth test
    glutInitWindowSize(1000, 800)  # Window size
    glutInitWindowPosition(0, 0)  # Window position
    wind = glutCreateWindow(b"3D OpenGL Intro")  # Create the window

    glutDisplayFunc(showScreen)  # Register display function
    glutKeyboardFunc(keyboardListener)  # Register keyboard listener
    glutSpecialFunc(specialKeyListener)
    glutMouseFunc(mouseListener)
    glutIdleFunc(idle)  # Register the idle function to move the bullet automatically

    glutMainLoop()  # Enter the GLUT main loop

if __name__ == "__main__":
    main()







#SABAH
from OpenGL.GL import *
from OpenGL.GLUT import *
from OpenGL.GLU import *
import random, sys

# Window dimensions
WIDTH, HEIGHT = 800, 600

# Grid size
GRID_LENGTH = 600

# Player properties
player_x = GRID_LENGTH // 2
player_y = 50
player_lives = 3
score = 0

# Game states
game_over = False
dead_pose = False
won_game = False  # <-- new flag

# Collectibles
collectibles = []

# ---------------- PLAYER MODEL ---------------- #
def draw_player_model():
    # Replace this with your Part 1 player model
    glColor3f(0, 0, 1)  # blue cube placeholder
    glutSolidCube(40)

def draw_player(alive=True):
    glPushMatrix()
    glTranslatef(player_x, player_y, 30)
    if not alive:
        glRotatef(90, 1, 0, 0)  # rotate to lie down
    draw_player_model()
    glPopMatrix()

# ---------------- DIAMOND (Collectible) ---------------- #
def draw_diamond(x, y, z, size):
    glPushMatrix()
    glTranslatef(x, y, z)
    glScalef(size, size, size)
    glColor3f(0.5, 0.8, 1.0)  # light blue

    glBegin(GL_TRIANGLES)
    # top pyramid
    glVertex3f(0, 0, 1); glVertex3f(-1, -1, 0); glVertex3f(1, -1, 0)
    glVertex3f(0, 0, 1); glVertex3f(1, -1, 0); glVertex3f(1, 1, 0)
    glVertex3f(0, 0, 1); glVertex3f(1, 1, 0); glVertex3f(-1, 1, 0)
    glVertex3f(0, 0, 1); glVertex3f(-1, 1, 0); glVertex3f(-1, -1, 0)
    # bottom pyramid
    glVertex3f(0, 0, -1); glVertex3f(-1, -1, 0); glVertex3f(1, -1, 0)
    glVertex3f(0, 0, -1); glVertex3f(1, -1, 0); glVertex3f(1, 1, 0)
    glVertex3f(0, 0, -1); glVertex3f(1, 1, 0); glVertex3f(-1, 1, 0)
    glVertex3f(0, 0, -1); glVertex3f(-1, 1, 0); glVertex3f(-1, -1, 0)
    glEnd()
    glPopMatrix()

# ---------------- GAME LOGIC ---------------- #
def spawn_collectibles():
    collectibles.clear()
    for _ in range(5):
        x = random.randint(50, GRID_LENGTH - 50)
        y = random.randint(100, GRID_LENGTH - 100)
        collectibles.append((x, y))

def check_collectibles():
    global score
    global collectibles
    for (cx, cy) in collectibles[:]:
        if abs(player_x - cx) < 30 and abs(player_y - cy) < 30:
            collectibles.remove((cx, cy))
            score += 1

def check_win():
    global score, game_over, won_game
    if player_y >= GRID_LENGTH - 50:
        score += 10
        game_over = True
        won_game = True  # player won

def reset_game():
    global player_x, player_y, player_lives, score
    global game_over, dead_pose, won_game
    player_x = GRID_LENGTH // 2
    player_y = 50
    player_lives = 3
    score = 0
    game_over = False
    dead_pose = False
    won_game = False
    spawn_collectibles()

# ---------------- DISPLAY ---------------- #
def draw_text(x, y, z, text):
    glRasterPos3f(x, y, z)
    for ch in text:
        glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, ord(ch))

def draw_scene():
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
    glLoadIdentity()
    gluLookAt(400, 400, 800, 400, 300, 0, 0, 1, 0)

    # Ground
    glColor3f(0.2, 0.8, 0.2)
    glBegin(GL_QUADS)
    glVertex3f(0, 0, 0); glVertex3f(GRID_LENGTH, 0, 0)
    glVertex3f(GRID_LENGTH, GRID_LENGTH, 0); glVertex3f(0, GRID_LENGTH, 0)
    glEnd()

    # Draw collectibles
    for (cx, cy) in collectibles:
        draw_diamond(cx, cy, 30, 10)

    # Draw player
    if not game_over:
        draw_player(alive=True)
    elif dead_pose:
        draw_player(alive=False)

    # HUD
    glColor3f(1, 1, 1)
    draw_text(10, 10, 200, f"Score: {score}  Lives: {player_lives}")

    if game_over:
        if won_game:
            draw_text(200, 300, 200, "YOU WIN! Press any key to play again")
        elif dead_pose:
            draw_text(200, 300, 200, "GAME OVER! Press any key to respawn")

    glutSwapBuffers()

# ---------------- INPUT ---------------- #
def keyboard(key, x, y):
    global player_x, player_y
    global player_lives, game_over, dead_pose
    if game_over:
        reset_game()
        return

    if key == b'a':  # left
        player_x -= 20
    elif key == b'd':  # right
        player_x += 20
    elif key == b'w':  # up
        player_y += 20
    elif key == b's':  # down
        player_y -= 20

    # boundaries
    player_x = max(20, min(GRID_LENGTH - 20, player_x))
    player_y = max(20, min(GRID_LENGTH - 20, player_y))

    check_collectibles()
    check_win()

def lose_life():
    global player_lives, game_over, dead_pose
    player_lives -= 1
    if player_lives <= 0:
        game_over = True
        dead_pose = True

def update(value):
    if not game_over:
        # Example: lose life randomly to simulate obstacles
        if random.random() < 0.01:
            lose_life()
    glutPostRedisplay()
    glutTimerFunc(100, update, 0)

# ---------------- MAIN ---------------- #
def main():
    glutInit(sys.argv)
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH)
    glutInitWindowSize(WIDTH, HEIGHT)
    glutCreateWindow(b"OpenGL Player Game")
    glEnable(GL_DEPTH_TEST)
    glutDisplayFunc(draw_scene)
    glutKeyboardFunc(keyboard)
    spawn_collectibles()
    glutTimerFunc(100, update, 0)
    glutMainLoop()

if __name__ == "__main__":
    main()












from OpenGL.GL import *
from OpenGL.GLU import *
from OpenGL.GLUT import *
import math, random, time
from OpenGL.GLUT import GLUT_BITMAP_HELVETICA_18

W,H = 1000, 800
fovY = 120.0  
ARENA = 600.0 


def render_text(x, y, txt, font=GLUT_BITMAP_HELVETICA_18):
    glColor3f(1, 1, 1)
    glMatrixMode(GL_PROJECTION)
    glPushMatrix()
    glLoadIdentity()
    gluOrtho2D(0, W, 0, H)
    glMatrixMode(GL_MODELVIEW)
    glPushMatrix()
    glLoadIdentity()
    glRasterPos2f(x, y)
    for c in txt:
        glutBitmapCharacter(font, ord(c))
    glPopMatrix()
    glMatrixMode(GL_PROJECTION)
    glPopMatrix()
    glMatrixMode(GL_MODELVIEW)

def create_floor():
    step = (ARENA * 2) // 13   
    start = -ARENA

    r = 0
    while r < 13:
        c = 0
        while c < 13:
            if (r + c) % 2 == 0: 
                color = (1, 1, 1)     
            else:
                color = (0.5, 0, 0.5)

            glColor3f(*color)

            x0, y0 = start + r * step, start + c * step
            x1, y1 = x0 + step, y0 + step

            glBegin(GL_QUADS)
            glVertex3f(x0, y0, 0.0)
            glVertex3f(x1, y0, 0.0)
            glVertex3f(x1, y1, 0.0)
            glVertex3f(x0, y1, 0.0)
            glEnd()

            c += 1
        r += 1

def create_walls():
    walls = [
        ((-ARENA, -ARENA, 0), (-ARENA, ARENA, 0), (-ARENA, ARENA, 120), (-ARENA, -ARENA, 120), (0,0,1)), 
        (( ARENA, -ARENA, 0), ( ARENA, ARENA, 0), ( ARENA, ARENA, 120), ( ARENA, -ARENA, 120), (0,1,0)), 
        ((-ARENA, ARENA, 0), ( ARENA, ARENA, 0), ( ARENA, ARENA, 120), (-ARENA, ARENA, 120), (0,1,1)),
        ((-ARENA, -ARENA, 0), ( ARENA, -ARENA, 0), ( ARENA, -ARENA, 120), (-ARENA, -ARENA, 120), (1,0,0)), 
    ]

    for i in walls:
        ver, color = i[:4], i[4]
        glColor3f(*color)
        glBegin(GL_QUADS)
        for j in ver:
            glVertex3f(*j)  
        glEnd()

def create_shooter():
    glPushMatrix()
    glTranslatef(0,0,0)
    ang=90

    if is_game_over == False:
        glRotatef(ang, 1, 0, 0)  
    
    q = gluNewQuadric()
    t= [0,0,0]

    if True:
        glPushMatrix()
        glColor3f(0, 0, 0)
        glTranslatef(0, 0, 90)
        gluSphere(q, 15, 15, 15)
        glPopMatrix()

        glPushMatrix()
        glColor3f(0.6, 0.4, 0.2)
        glTranslatef(0, 0, 60)
        glScalef(40, 20, 50)
        glutSolidCube(1)
        glPopMatrix()

        side_index = 0
        sides = [-1, 1]
        while side_index < len(sides):
            s_d = sides[side_index]

            glPushMatrix()
            glColor3f(1.0, 0.8, 0.6)
            glTranslatef(0, s_d * 30, 70)  
            glRotatef(90, 1, 0, 0)        
            gluCylinder(q, 5, 5, 20, 15, 15)  
            glPopMatrix()

            glPushMatrix()
            glColor3f(1.0, 0.8, 0.6)
            glTranslatef(0, s_d * 30, 70)
            gluSphere(q, 6, 15, 15)
            glPopMatrix()

            side_index += 1

        leg_index = 0
        offsets = [-15, 15]
        while leg_index < len(offsets):
            off = offsets[leg_index]
            glPushMatrix()
            glColor3f(0, 0, 1)
            glTranslatef(off, 0, 10)
            glScalef(10, 10, 40)
            glutSolidCube(1)
            glPopMatrix()
            leg_index += 1

    glPushMatrix()
    glColor3f(0.3, 0.3, 0.9)


    
    y_offset = 20
    z_offset = 60 
    glTranslatef(0, y_offset, z_offset)

    glPushMatrix()
    glRotatef(-90, 0, 1, 0) 

    glPushMatrix()
    glTranslatef(0, 0, 60)
    t = glGetFloatv(GL_MODELVIEW_MATRIX)[3][:3]
    glPopMatrix()

    gluCylinder(q, 3, 1, 60, 10, 10)
    glTranslatef(0, 0, 60)
    glColor3f(1, 1, 0)
    glutSolidCube(5)

    glPopMatrix() 
    glPopMatrix()  

l= []
def create_obstacle(p, q):
    glPushMatrix()
    glTranslatef(p.x, p.y, p.z) 
    glColor3f(1, 0, 0)
    gluCylinder(q, 40, 20, 20)   
    glPushMatrix()
    glTranslatef(0, 0, 40 * 1.2)
    glColor3f(0, 0, 0)
    gluCylinder(q,40 * 0., 10, 10)
    glPopMatrix()
    glPopMatrix()

def create_obstacles():
    q = gluNewQuadric() 
    for p in l:
        create_obstacle(p, q)

b=[]
def create_bullets():
    i = 0
    q = gluNewQuadric()   
    while i < len(b):
        g = b[i]

        if not g.active:
            b.remove(g)  
            continue

        glPushMatrix()
        glTranslatef(g.x, g.y, g.z)

        pulse = 0.1 * math.sin(g.reach * 0.5) + 1.0
        cur_size = g.radius * pulse

        glColor3f(1, 0, 0)
        gluCylinder(q, cur_size, cur_size, 15, 15)

        glColor4f(1, 1, 0.5, 0.7)
        gluCylinder(q, cur_size * 0.8, cur_size * 0.8, 10, 10)

        glColor4f(1, 0.8, 0, 0.3)
        gluCylinder(q, cur_size * 1.5, cur_size * 1.5, 10, 10)

        glPopMatrix()
        i += 1

class Obstacle:
    def __init__(self):
        self.rad = 40
        self.velocity = 0.03
        self.z = 0
        self.generate()

    def generate(self):
        self.x, self.y = self._random_position()
        while not self._is_far_from_hero():
            self.x, self.y = self._random_position()

    def _random_position(self):
        return (random.uniform(-ARENA + 40, ARENA - 40),
                random.uniform(-ARENA + 40, ARENA - 40))

    def _is_far_from_hero(self):
        return math.hypot(self.x, self.y) > 200

class Bullet: 
    def __init__(self, x, y, z, a): 
        self.x, self.y, self.z = x, y, z 
        self.a = a
        self.radius = 5
        self.velocity = 0.3
        self.reach = 0 
        self.active = True

def init_obstacles(count=5): 
    return [Obstacle() for _ in range(count)]
obstacles = init_obstacles()

lives_left = 5        

def move_obstacles(lives_left):
    global is_game_over

    i = 0
    while i < len(l):
        me = l[i]

        dx, dy = 0 - me.x , 0 - me.y
        distance = math.hypot(dx, dy)

        if distance > 30 + me.rad:
            s = me.velocity * 2
            ratio = s / distance  
            me.x += dx * ratio
            me.y += dy * ratio

        elif not is_game_over:  
            lives_left -= 1
            print("Player Life Remaining:", lives_left)
            if lives_left <= 0:
                is_game_over = True
            me.generate() 
        i += 1

miss_bullets = 0
points = 0

def move_bullets(miss_bullets, points):
    i = 0
    while i < len(b):
        bullet = b[i]

        if bullet.active:
            rad = math.radians(bullet.angle)
            dx = math.sin(rad) * bullet.velocity
            dy = math.cos(rad) * bullet.velocity
            bullet.x += dx
            bullet.y += dy
            bullet.reach += bullet.velocity

            obstacle_hit = False
            j = 0
            while j < len(l):
                obs = l[j]
                distance = math.hypot(bullet.x - obs.x, bullet.y - obs.y)
                if distance < bullet.radius + obs.rad:
                    obs.generate()       
                    obstacle_hit = True
                    break
                j += 1

            if obstacle_hit or abs(bullet.x) > ARENA or abs(bullet.y) > ARENA or bullet.reach > ARENA*2:
                bullet.active = False
                if obstacle_hit:
                    points += 1
                else:
                    miss_bullets += 1
                    print("Player Bullet Missed:", miss_bullets)

        i += 1

p_fire = 0
g_fire = 0.3
def shot():
    global p_fire
    now = time.time()
    if now - p_fire < g_fire: 
        return
    p_fire = now
    ang = 0 
    b.append(Bullet(0, 0, 0, ang))

def setupCamera():
    
    glMatrixMode(GL_PROJECTION)
    glLoadIdentity()
    gluPerspective(fovY, 1.25, 0.1, 1500)
    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()


def keyboardListener(key, x, y):


  


def mouseListener (button, state, x, y, focus_camera=False):

    if state != GLUT_DOWN:
        return  
    if button == GLUT_LEFT_BUTTON and is_game_over== False:
        shot()

    elif button == GLUT_RIGHT_BUTTON:
        focus_camera = not focus_camera

def specialKeyListener(key, x, y):

def idle():
     glutPostRedisplay()

def showScreen():
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
    glLoadIdentity()
    setupCamera()

    create_floor()
    create_walls()
    create_shooter()
    create_obstacles()
    create_bullets()

    

    glutSwapBuffers()


glutInit()
glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH)
glutInitWindowSize(W,H)
glutInitWindowPosition(0, 0)
wind = glutCreateWindow(b"Bullet Frenzy - A 3D Game with Player Movement, Shooting, & Cheat Modes")
glEnable(GL_DEPTH_TEST)
init_obstacles()
glutDisplayFunc(showScreen)
glutKeyboardFunc(keyboardListener)
glutSpecialFunc(specialKeyListener)
glutMouseFunc(mouseListener)
glutIdleFunc(idle)
glutMainLoop()